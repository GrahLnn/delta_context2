import os
import subprocess
import re
from typing import TextIO, List, Dict
from pathlib import Path
from alive_progress import alive_bar


class WriteASS:
    extension: str = "ass"

    def __init__(self, output_dir: str):
        self.output_dir = output_dir

    def __call__(self, result: List[Dict[str, float]], output_filename: str):
        output_path = os.path.join(
            self.output_dir, f"{output_filename}.{self.extension}"
        )
        with open(output_path, "w", encoding="utf-8") as f:
            self.write_result(result, file=f)

    def write_result(self, result: List[Dict[str, float]], file: TextIO):
        # 写入ASS文件头部信息
        file.write("[Script Info]\n")
        file.write("Title: Generated by WriteASS\n")
        file.write("ScriptType: v4.00+\n")
        file.write("WrapStyle: 0\n")
        file.write("\n")

        # 写入样式信息
        file.write("[V4+ Styles]\n")
        file.write(
            "Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n"
        )
        file.write(
            "Style: 仓耳今楷,仓耳今楷03 W04,18,&H00F7C34F,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.5,2,2,5,10,1,1\n"
        )
        file.write("\n")

        # 写入事件
        file.write("[Events]\n")
        file.write(
            "Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n"
        )

        for segment in result:
            start_time = self.format_timestamp(segment["start"])
            end_time = self.format_timestamp(segment["end"])
            text = segment["text"]
            file.write(f"Dialogue: 0,{start_time},{end_time},仓耳今楷,,0,0,0,,{text}\n")

    def format_timestamp(self, seconds: float):
        # 转换时间格式为ASS文件所需的"hh:mm:ss.cc"形式
        milliseconds = round(seconds * 100)
        minutes, milliseconds = divmod(milliseconds, 6000)
        hours, minutes = divmod(minutes, 60)
        seconds, centiseconds = divmod(milliseconds, 100)

        return f"{hours:02d}:{minutes:02d}:{seconds:02d}.{centiseconds:02d}"


# 保存为ASS字幕的函数
def save_to_ass(result: List[Dict[str, float]], output_filename: str, output_dir: str):
    writer = WriteASS(output_dir)
    writer(result, output_filename)
    return Path(output_dir) / f"{output_filename}.ass"


def get_seconds(time_str):
    """将时间字符串转换为秒数"""
    h, m, s = map(float, time_str.split(":"))
    return int(h) * 3600 + int(m) * 60 + s


def render_video_with_subtitles(video_path: str, subtitles_path: str, output_path: str):
    """
    使用 ffmpeg 渲染带字幕的视频。

    :param video_path: 输入视频文件的路径
    :param subtitles_path: ASS 字幕文件的路径
    :param output_path: 输出带字幕视频的路径
    """

    video_path = Path(video_path).as_posix()
    subtitles_path = Path(subtitles_path).as_posix()
    output_path = (Path(output_path) / f"{Path(video_path).stem}.mp4").as_posix()

    cmd = [
        "ffmpeg",
        "-i",
        video_path,  # 输入视频文件
        "-vf",
        f"ass={subtitles_path}",  # 添加字幕滤镜
        "-c:a",
        "copy",  # 复制音频（不重新编码）
        "-y",  # 覆盖输出文件（如果存在）
        output_path,  # 输出视频文件
    ]

    process = subprocess.Popen(
        cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        encoding="utf-8",
        text=True,
    )

    duration = None
    progress = [0]

    # 使用 alive_progress 显示进度条
    with alive_bar(100, title="render subtitle", manual=True) as bar:
        for line in process.stdout:
            if duration is None:
                match = re.search(r"Duration: (\d{2}:\d{2}:\d{2}\.\d{2}),", line)
                if match:
                    duration = get_seconds(match.group(1))

            match = re.search(r"time=(\d{2}:\d{2}:\d{2}\.\d{2})", line)
            if match:
                elapsed_time = get_seconds(match.group(1))
                if duration:
                    progress = round(elapsed_time / duration, 2)
                    bar(progress)

    process.wait()
